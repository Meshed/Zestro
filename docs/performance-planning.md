# Zestro Performance Planning Document
*Generated by Sally (UX Expert) - September 9, 2025*

## Table of Contents
1. [Performance Requirements](#performance-requirements)
2. [Lazy Loading Strategies](#lazy-loading-strategies)
3. [Database Optimization](#database-optimization)
4. [Mobile Performance Optimization](#mobile-performance-optimization)
5. [Elm-Specific Performance Patterns](#elm-specific-performance-patterns)
6. [Implementation Roadmap](#implementation-roadmap)

---

## Performance Requirements

### Critical Performance Targets
From the Zestro PRD, we need to meet these essential targets:

- **Application load**: <3 seconds
- **Shopping list generation**: <10 seconds (up to 20 recipes)
- **Recipe entry**: Smooth, no blocking during autocomplete
- **Mobile shopping experience**: Instant interactions, offline-capable

### Performance Risk Areas
1. **Large recipe collections** (100+ recipes) causing slow initial loads
2. **Global ingredient/tag systems** requiring fast autocomplete (<200ms)
3. **Shopping list aggregation** across multiple scaled recipes
4. **Mobile battery consumption** during extended shopping sessions

---

## Lazy Loading Strategies

### Virtual Scrolling for Recipe Collections

#### Problem Analysis
As users build substantial recipe libraries (100+ recipes), loading everything at once becomes problematic:
- **Initial page load**: Hundreds of recipe cards = slow rendering
- **Memory usage**: Large recipe collections consume significant browser memory
- **Search performance**: Filtering large datasets blocks the UI thread

#### Elm Virtual Scrolling Implementation

```elm
-- VIRTUAL SCROLLING MODEL
type alias VirtualScrollModel =
    { visibleStartIndex : Int
    , visibleEndIndex : Int
    , itemHeight : Float
    , containerHeight : Float
    , totalItems : Int
    , bufferedItems : List Recipe
    , scrollPosition : Float
    }

-- LAZY LOADING MESSAGES
type LazyLoadMsg
    = ScrollPositionChanged Float
    | LoadMoreRecipes Int Int  -- start index, count
    | RecipesBatchLoaded (List Recipe)
    | PreloadNextBatch

-- VIRTUAL SCROLL UPDATE
updateVirtualScroll : LazyLoadMsg -> VirtualScrollModel -> ( VirtualScrollModel, Cmd LazyLoadMsg )
updateVirtualScroll msg model =
    case msg of
        ScrollPositionChanged newPosition ->
            let
                visibleStart = floor (newPosition / model.itemHeight)
                visibleEnd = visibleStart + floor (model.containerHeight / model.itemHeight) + 5 -- buffer
            in
            if visibleEnd > List.length model.bufferedItems - 10 then
                -- Need to load more
                ( { model 
                    | scrollPosition = newPosition
                    , visibleStartIndex = visibleStart
                    , visibleEndIndex = visibleEnd
                  }
                , loadRecipeBatch (List.length model.bufferedItems) 20
                )
            else
                ( { model 
                    | scrollPosition = newPosition
                    , visibleStartIndex = visibleStart  
                    , visibleEndIndex = visibleEnd
                  }
                , Cmd.none
                )
```

### Progressive Recipe Card Loading

```elm
-- RECIPE CARD STATES
type RecipeLoadState
    = NotLoaded
    | Loading  
    | Loaded Recipe
    | LoadError String

-- PROGRESSIVE LOADING VIEW
viewRecipeCard : RecipeLoadState -> Html Msg
viewRecipeCard loadState =
    case loadState of
        NotLoaded ->
            div [ class "recipe-card-skeleton" ]
                [ div [ class "skeleton-image" ] []
                , div [ class "skeleton-text" ] []
                , div [ class "skeleton-tags" ] []
                ]
                
        Loading ->
            div [ class "recipe-card-loading" ]
                [ div [ class "loading-spinner" ] []
                , text "Loading recipe..."
                ]
                
        Loaded recipe ->
            viewFullRecipeCard recipe
            
        LoadError error ->
            div [ class "recipe-card-error" ]
                [ text ("Failed to load: " ++ error)
                , button [ onClick RetryLoad ] [ text "Retry" ]
                ]
```

### Smart Preloading Strategy

```elm
-- PRELOADING LOGIC
type PreloadStrategy
    = PreloadVisible -- Load only what's on screen
    | PreloadAggressive -- Load ahead based on scroll direction
    | PreloadByTags -- Prioritize by user's filtering behavior
    | PreloadFavorites -- Load starred recipes first

-- PRELOAD DECISION ALGORITHM  
determinePreloadPriority : FilterState -> List RecipeId -> List RecipeId
determinePreloadPriority filters recipeIds =
    recipeIds
        |> List.sortBy (calculatePreloadScore filters)
        |> List.take 50 -- Only preload top 50 candidates

calculatePreloadScore : FilterState -> RecipeId -> Float  
calculatePreloadScore filters recipeId =
    let
        tagMatchScore = calculateTagMatchScore filters.selectedTags recipeId
        recentUsageScore = calculateRecentUsageScore recipeId
        favoriteBonus = if isFavorite recipeId then 10.0 else 0.0
    in
    tagMatchScore + recentUsageScore + favoriteBonus
```

### Efficient Recipe Search & Filtering

#### Client-Side Search Optimization
```elm
-- INDEXED SEARCH FOR PERFORMANCE
type alias SearchIndex =
    { byName : Dict String (List RecipeId)
    , byIngredient : Dict String (List RecipeId)  
    , byTag : Dict String (List RecipeId)
    , fullTextIndex : Dict String (List RecipeId)
    }

-- DEBOUNCED SEARCH TO AVOID EXCESSIVE FILTERING
type alias SearchState =
    { query : String
    , debouncedQuery : String
    , searchTimer : Maybe Timer
    , results : List Recipe
    , isSearching : Bool
    }

-- SEARCH UPDATE WITH DEBOUNCING
updateSearch : String -> SearchState -> ( SearchState, Cmd Msg )
updateSearch newQuery state =
    let
        newTimer = Timer.debounce 300 (PerformSearch newQuery)
    in
    ( { state 
        | query = newQuery
        , searchTimer = Just newTimer
        , isSearching = True
      }
    , Timer.start newTimer
    )

-- EFFICIENT SEARCH EXECUTION
performSearch : String -> SearchIndex -> List RecipeId
performSearch query index =
    if String.length query < 2 then
        []
    else
        let
            nameMatches = Dict.get query index.byName |> Maybe.withDefault []
            ingredientMatches = Dict.get query index.byIngredient |> Maybe.withDefault []
            tagMatches = Dict.get query index.byTag |> Maybe.withDefault []
        in
        nameMatches ++ ingredientMatches ++ tagMatches
            |> List.Extra.unique
            |> List.take 100 -- Limit results for performance
```

---

## Database Optimization

### Critical Performance Challenges

The global ingredient, unit, and tag systems present unique scaling challenges:
- **Autocomplete queries**: Must be <200ms even with 100k+ ingredients
- **Concurrent recipe entry**: Multiple users creating ingredients simultaneously
- **Shopping list aggregation**: Complex joins across recipes → ingredients → global tables
- **Tag search**: Fuzzy matching across growing tag library

### PostgreSQL Schema Optimization

#### Global Ingredients Table Design
```sql
-- OPTIMIZED GLOBAL INGREDIENTS TABLE
CREATE TABLE global_ingredients (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    normalized_name VARCHAR(255) NOT NULL, -- lowercase for matching
    display_name VARCHAR(255) NOT NULL,    -- Title Case for display  
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_by UUID REFERENCES users(id),
    usage_count INTEGER DEFAULT 1,
    is_verified BOOLEAN DEFAULT FALSE      -- crowd-sourced verification
);

-- CRITICAL INDEXES FOR PERFORMANCE
CREATE INDEX idx_ingredients_normalized_name ON global_ingredients 
    USING btree (normalized_name varchar_pattern_ops);

CREATE INDEX idx_ingredients_display_name_trigram ON global_ingredients 
    USING gin (display_name gin_trgm_ops);

CREATE INDEX idx_ingredients_usage_count ON global_ingredients (usage_count DESC);

CREATE INDEX idx_ingredients_search_composite ON global_ingredients 
    (normalized_name, usage_count DESC, is_verified DESC);
```

#### F# Database Access Optimization
```fsharp
// EFFICIENT INGREDIENT SEARCH WITH CACHING
module IngredientDb = 
    
    // SEARCH WITH TRIGRAM MATCHING + CACHING
    let searchIngredients (query: string) (maxResults: int) : Async<Ingredient list> =
        async {
            let normalizedQuery = query.ToLower().Trim()
            let cacheKey = $"ingredient_search_{normalizedQuery}_{maxResults}"
            
            match! Cache.tryGet cacheKey with
            | Some cached -> return cached
            | None ->
                let! results = 
                    query
                    |> sql """
                        SELECT id, display_name, usage_count, is_verified
                        FROM global_ingredients 
                        WHERE normalized_name ILIKE @query || '%'
                        OR display_name % @query  -- trigram similarity
                        ORDER BY 
                            CASE WHEN normalized_name = @query THEN 1 ELSE 2 END,
                            usage_count DESC,
                            is_verified DESC,
                            similarity(display_name, @query) DESC
                        LIMIT @maxResults
                    """
                    |> param "@query" normalizedQuery
                    |> param "@maxResults" maxResults
                    |> execute<Ingredient>
                    
                do! Cache.set cacheKey results (TimeSpan.FromMinutes(15.0))
                return results
        }

    // BULK INGREDIENT CREATION FOR RECIPE ENTRY
    let createIngredientsIfNotExists (ingredients: NewIngredient list) : Async<Ingredient list> =
        async {
            let! existing = 
                ingredients
                |> List.map (fun i -> i.Name.ToLower().Trim())
                |> getExistingIngredientsByNames
                
            let toCreate = 
                ingredients
                |> List.filter (fun ing -> 
                    not (existing |> List.exists (fun ex -> ex.NormalizedName = ing.Name.ToLower().Trim())))
                    
            let! created = 
                toCreate
                |> List.map createNewIngredient
                |> Async.Parallel
                
            return (existing @ (Array.toList created))
        }
```

### Shopping List Aggregation Optimization
```fsharp
// OPTIMIZED SHOPPING LIST GENERATION
module ShoppingListGenerator =
    
    // SINGLE QUERY FOR ENTIRE MEAL PLAN AGGREGATION
    let generateShoppingList (mealPlanId: Guid) : Async<ShoppingList> =
        async {
            let! aggregatedIngredients = 
                query
                |> sql """
                    WITH scaled_ingredients AS (
                        SELECT 
                            ri.recipe_id,
                            gi.id as ingredient_id,
                            gi.display_name,
                            gu.display_name as unit_name,
                            ri.quantity * COALESCE(mpi.scale_factor, 1.0) as scaled_quantity,
                            ri.unit_id
                        FROM meal_plan_items mpi
                        JOIN recipe_ingredients ri ON mpi.recipe_id = ri.recipe_id  
                        JOIN global_ingredients gi ON ri.ingredient_id = gi.id
                        JOIN global_units gu ON ri.unit_id = gu.id
                        WHERE mpi.meal_plan_id = @mealPlanId
                    ),
                    unit_converted AS (
                        SELECT 
                            ingredient_id,
                            display_name,
                            SUM(scaled_quantity * COALESCE(uc.conversion_factor, 1.0)) as total_quantity,
                            COALESCE(uc.target_unit_name, unit_name) as final_unit
                        FROM scaled_ingredients si
                        LEFT JOIN unit_conversions uc ON si.unit_id = uc.from_unit_id
                        GROUP BY ingredient_id, display_name, final_unit
                    )
                    SELECT 
                        ingredient_id,
                        display_name,
                        total_quantity,
                        final_unit,
                        ic.category_name
                    FROM unit_converted uc
                    JOIN ingredient_categories ic ON uc.ingredient_id = ic.ingredient_id
                    ORDER BY ic.store_order, uc.display_name
                """
                |> param "@mealPlanId" mealPlanId
                |> execute<AggregatedIngredient>
                
            return createShoppingListFromIngredients aggregatedIngredients
        }
```

### Global Tag System Performance

#### Tag Search with Full-Text Indexing
```sql
-- OPTIMIZED GLOBAL TAGS TABLE
CREATE TABLE global_tags (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL UNIQUE,
    normalized_name VARCHAR(100) NOT NULL,
    category VARCHAR(50), -- cuisine, meal_type, difficulty, etc.
    usage_count INTEGER DEFAULT 1,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    search_vector tsvector GENERATED ALWAYS AS (to_tsvector('english', name)) STORED
);

-- FULL-TEXT SEARCH INDEX
CREATE INDEX idx_tags_search_vector ON global_tags USING gin(search_vector);
CREATE INDEX idx_tags_normalized_name ON global_tags (normalized_name varchar_pattern_ops);
CREATE INDEX idx_tags_category_usage ON global_tags (category, usage_count DESC);
```

#### F# Tag Search Implementation
```fsharp
// HIGH-PERFORMANCE TAG AUTOCOMPLETE
module TagDb =
    
    let searchTags (query: string) (limit: int) : Async<Tag list> =
        async {
            let normalizedQuery = query.ToLower().Trim()
            
            let! results =
                query  
                |> sql """
                    SELECT id, name, category, usage_count
                    FROM global_tags
                    WHERE 
                        normalized_name ILIKE @query || '%'
                        OR search_vector @@ plainto_tsquery('english', @query)
                        OR name % @query
                    ORDER BY
                        CASE WHEN normalized_name = @query THEN 1 ELSE 2 END,
                        usage_count DESC,
                        ts_rank_cd(search_vector, plainto_tsquery('english', @query)) DESC,
                        similarity(name, @query) DESC
                    LIMIT @limit
                """
                |> param "@query" normalizedQuery  
                |> param "@limit" limit
                |> execute<Tag>
                
            return results
        }
```

### Connection Pool & Caching Strategy

#### F# Connection Management
```fsharp
// OPTIMIZED CONNECTION POOL CONFIGURATION
module Database =
    
    let connectionPool = 
        NpgsqlDataSource.builder connectionString
            .MinPoolSize(10)
            .MaxPoolSize(100)
            .ConnectionLifetime(TimeSpan.FromMinutes(30.0))
            .ConnectionIdleLifetime(TimeSpan.FromMinutes(5.0))
            .Build()
    
    // REDIS CACHING FOR GLOBAL DATA
    let cache = RedisConnection.GetDatabase()
    
    let withCaching<'T> (cacheKey: string) (expiry: TimeSpan) (fetchData: unit -> Async<'T>) : Async<'T> =
        async {
            let! cached = cache.StringGetAsync(cacheKey) |> Async.AwaitTask
            
            if cached.HasValue then
                return JsonSerializer.Deserialize<'T>(cached)
            else
                let! fresh = fetchData()
                let serialized = JsonSerializer.Serialize(fresh)
                do! cache.StringSetAsync(cacheKey, serialized, expiry) |> Async.AwaitTask |> Async.Ignore
                return fresh
        }
```

---

## Mobile Performance Optimization

### Critical Mobile Performance Goals
- **Shopping list loads**: <2 seconds even on 3G
- **Offline functionality**: Core shopping list works without network
- **Touch interactions**: <100ms response time
- **Battery efficiency**: Minimal background processing

### Progressive Web App (PWA) Architecture

#### Service Worker for Offline Shopping Lists
```javascript
// SERVICE WORKER FOR OFFLINE SHOPPING EXPERIENCE
const CACHE_NAME = 'zestro-shopping-v1';
const CRITICAL_RESOURCES = [
    '/shopping-list',
    '/assets/shopping-list.css', 
    '/assets/shopping-list.js',
    '/offline.html'
];

// CACHE SHOPPING LISTS FOR OFFLINE USE
self.addEventListener('fetch', event => {
    if (event.request.url.includes('/api/shopping-list/')) {
        event.respondWith(
            caches.match(event.request)
                .then(response => {
                    if (response) {
                        // Return cached version immediately
                        fetchAndUpdateCache(event.request); // Update in background
                        return response;
                    }
                    return fetch(event.request)
                        .then(response => {
                            if (response.status === 200) {
                                updateCache(event.request, response.clone());
                            }
                            return response;
                        })
                        .catch(() => caches.match('/offline.html'));
                })
        );
    }
});

// BACKGROUND SYNC FOR SHOPPING LIST UPDATES
self.addEventListener('sync', event => {
    if (event.tag === 'shopping-list-sync') {
        event.waitUntil(syncShoppingListUpdates());
    }
});

async function syncShoppingListUpdates() {
    const pendingUpdates = await getStoredUpdates();
    for (const update of pendingUpdates) {
        try {
            await fetch('/api/shopping-list/update', {
                method: 'POST',
                body: JSON.stringify(update)
            });
            await removePendingUpdate(update.id);
        } catch (error) {
            console.log('Sync failed, will retry later');
        }
    }
}
```

#### Elm Mobile Performance Optimizations
```elm
-- MOBILE-OPTIMIZED SHOPPING LIST MODEL
type alias MobileShoppingListModel =
    { items : Dict ItemId ShoppingItem
    , categories : List Category
    , checkedItems : Set ItemId
    , expandedCategories : Set CategoryId
    , syncStatus : SyncStatus
    , touchState : TouchState
    , swipeThreshold : Float
    , checkoffAnimation : Dict ItemId AnimationState
    }

type SyncStatus
    = Synced
    | PendingSync (List ItemUpdate)
    | SyncError String
    | Offline

type TouchState
    = NoTouch
    | TouchStart ItemId Touch.Coordinates Time.Posix
    | Swiping ItemId Float -- swipe distance
    | SwipeComplete ItemId

-- OPTIMIZED UPDATE FOR MOBILE INTERACTIONS
updateMobile : MobileShoppingMsg -> MobileShoppingListModel -> ( MobileShoppingListModel, Cmd MobileShoppingMsg )
updateMobile msg model =
    case msg of
        TouchStart itemId coordinates ->
            ( { model | touchState = TouchStart itemId coordinates (Time.millisToPosix 0) }
            , Task.perform (TouchStartTime itemId coordinates) Time.now
            )
            
        TouchMove itemId coordinates ->
            case model.touchState of
                TouchStart startItemId startCoords startTime ->
                    if itemId == startItemId then
                        let
                            swipeDistance = calculateSwipeDistance startCoords coordinates
                        in
                        if swipeDistance > model.swipeThreshold then
                            -- Trigger haptic feedback
                            ( { model | touchState = SwipeComplete itemId }
                            , Cmd.batch 
                                [ triggerHapticFeedback
                                , toggleItemChecked itemId
                                ]
                            )
                        else
                            ( { model | touchState = Swiping itemId swipeDistance }
                            , Cmd.none
                            )
                    else
                        ( model, Cmd.none )
                        
                _ ->
                    ( model, Cmd.none )

        -- OFFLINE-FIRST ITEM TOGGLE
        ToggleItemChecked itemId ->
            let
                newCheckedItems = 
                    if Set.member itemId model.checkedItems then
                        Set.remove itemId model.checkedItems
                    else
                        Set.insert itemId model.checkedItems
                        
                update = ItemToggled itemId (Set.member itemId newCheckedItems)
                
                newSyncStatus = 
                    case model.syncStatus of
                        Synced -> PendingSync [update]
                        PendingSync pending -> PendingSync (update :: pending)
                        _ -> model.syncStatus
            in
            ( { model 
                | checkedItems = newCheckedItems
                , syncStatus = newSyncStatus
              }
            , Cmd.batch
                [ storeLocalUpdate update  -- Save to IndexedDB
                , attemptBackgroundSync    -- Try to sync if online
                , animateCheckoff itemId   -- Visual feedback
                ]
            )
```

#### Efficient Mobile View Rendering
```elm
-- OPTIMIZED MOBILE SHOPPING LIST VIEW
viewMobileShoppingList : MobileShoppingListModel -> Html MobileShoppingMsg
viewMobileShoppingList model =
    div [ class "mobile-shopping-container" ]
        [ lazy viewHeader model.syncStatus
        , lazy2 viewProgress (Set.size model.checkedItems) (totalItemCount model)
        , div [ class "categories-container" ]
            (model.categories 
                |> List.map (lazy3 viewCategory model.checkedItems model.touchState)
            )
        , lazy viewOfflineIndicator model.syncStatus
        ]

-- LAZY CATEGORY RENDERING TO AVOID UNNECESSARY REDRAWS
viewCategory : Set ItemId -> TouchState -> Category -> Html MobileShoppingMsg
viewCategory checkedItems touchState category =
    let
        isExpanded = -- category expansion logic
        categoryItems = -- filter items for this category
    in
    div 
        [ class "shopping-category"
        , classList [("expanded", isExpanded)]
        ]
        [ viewCategoryHeader category
        , if isExpanded then
            div [ class "category-items" ]
                (categoryItems
                    |> List.map (lazy3 viewShoppingItem checkedItems touchState)
                )
          else
            text ""
        ]

-- OPTIMIZED ITEM RENDERING WITH VIRTUALIZATION FOR LONG LISTS
viewShoppingItem : Set ItemId -> TouchState -> ShoppingItem -> Html MobileShoppingMsg
viewShoppingItem checkedItems touchState item =
    let
        isChecked = Set.member item.id checkedItems
        swipeOffset = getSwipeOffset item.id touchState
        
        -- Only render expensive animations if item is being interacted with
        itemClasses = 
            [ ("shopping-item", True)
            , ("checked", isChecked)
            , ("swiping", swipeOffset > 0)
            , ("animating", swipeOffset > 0)
            ]
    in
    div 
        [ classList itemClasses
        , style "transform" 
            (if swipeOffset > 0 then 
                "translateX(" ++ String.fromFloat swipeOffset ++ "px)"
             else 
                "none"
            )
        -- Touch events with passive listeners for better scroll performance
        , onTouchStartPassive (TouchStart item.id)
        , onTouchMovePassive (TouchMove item.id)
        , onTouchEndPassive (TouchEnd item.id)
        , onClick (ToggleItemChecked item.id)
        ]
        [ viewItemCheckbox isChecked
        , viewItemContent item
        , viewSwipeAction
        ]
```

### Battery & Performance Optimizations

#### Request Batching & Debouncing
```elm
-- BATCHED SYNC UPDATES TO REDUCE BATTERY DRAIN
type alias SyncBatcher =
    { pendingUpdates : List ItemUpdate
    , batchTimer : Maybe Timer
    , lastSyncTime : Time.Posix
    , syncInProgress : Bool
    }

-- BATCH MULTIPLE RAPID INTERACTIONS
batchSyncUpdate : ItemUpdate -> SyncBatcher -> ( SyncBatcher, Cmd Msg )
batchSyncUpdate update batcher =
    let
        updatedPending = update :: batcher.pendingUpdates
        
        -- Only start new timer if one isn't already running
        newTimer = 
            case batcher.batchTimer of
                Nothing -> Just (Timer.debounce 2000 FlushSyncBatch)
                existing -> existing
    in
    ( { batcher 
        | pendingUpdates = updatedPending
        , batchTimer = newTimer
      }
    , case newTimer of
        Just timer -> Timer.start timer
        Nothing -> Cmd.none
    )

-- FLUSH BATCHED UPDATES EFFICIENTLY  
flushSyncBatch : SyncBatcher -> ( SyncBatcher, Cmd Msg )
flushSyncBatch batcher =
    if List.isEmpty batcher.pendingUpdates || batcher.syncInProgress then
        ( batcher, Cmd.none )
    else
        ( { batcher 
            | syncInProgress = True
            , batchTimer = Nothing
          }
        , syncBatchToServer batcher.pendingUpdates
        )
```

#### Memory Management for Large Shopping Lists
```elm
-- MEMORY-EFFICIENT SHOPPING LIST MANAGEMENT
type alias OptimizedShoppingModel =
    { visibleItems : Dict ItemId ShoppingItem  -- Only items currently on screen
    , itemIndex : Dict ItemId ItemMetadata     -- Lightweight metadata for all items
    , categoryGroups : Dict CategoryId (List ItemId)
    , viewport : Viewport
    , itemPool : ItemPool  -- Reuse item components
    }

-- ITEM POOLING TO REDUCE GC PRESSURE
type alias ItemPool =
    { available : List (Html Msg)
    , inUse : Dict ItemId (Html Msg)
    , poolSize : Int
    }

-- RECYCLE ITEM COMPONENTS INSTEAD OF RECREATING
recycleItemComponent : ItemId -> ShoppingItem -> ItemPool -> ( Html Msg, ItemPool )
recycleItemComponent itemId item pool =
    case pool.available of
        recycled :: remaining ->
            let
                updatedComponent = updateItemComponent recycled item
                newInUse = Dict.insert itemId updatedComponent pool.inUse
                newAvailable = remaining
            in
            ( updatedComponent
            , { pool | available = newAvailable, inUse = newInUse }
            )
            
        [] ->
            let
                newComponent = createItemComponent item
                newInUse = Dict.insert itemId newComponent pool.inUse
            in
            ( newComponent
            , { pool | inUse = newInUse }
            )
```

---

## Elm-Specific Performance Patterns

### Functional Programming Performance Best Practices

Elm's functional nature provides unique optimization opportunities that align perfectly with Zestro's architecture:

### Strategic Use of `lazy` for Expensive View Components

#### Recipe Card Lazy Evaluation
```elm
-- EXPENSIVE RECIPE CARD RENDERING
viewRecipeCard : Recipe -> Html Msg
viewRecipeCard recipe =
    div [ class "recipe-card" ]
        [ viewRecipeImage recipe.imageUrl        -- Expensive: image processing
        , viewRecipeContent recipe               -- Expensive: markdown rendering
        , viewRecipeTags recipe.tags            -- Expensive: tag filtering/sorting
        , viewNutritionInfo recipe.nutrition    -- Expensive: calculations
        ]

-- OPTIMIZED WITH STRATEGIC LAZY USAGE
viewRecipeCardOptimized : Recipe -> Html Msg  
viewRecipeCardOptimized recipe =
    div [ class "recipe-card" ]
        [ lazy2 viewRecipeImage recipe.id recipe.imageUrl
        , lazy viewRecipeContent recipe
        , lazy2 viewRecipeTags recipe.id recipe.tags
        , lazy2 viewNutritionInfo recipe.id recipe.nutrition
        ]

-- LAZY FUNCTIONS WITH STABLE KEYS
viewRecipeImage : RecipeId -> String -> Html Msg
viewRecipeImage recipeId imageUrl =
    -- Implementation that only re-renders when recipeId or imageUrl changes
    img 
        [ src imageUrl
        , alt ("Recipe " ++ Recipe.toString recipeId)
        , class "recipe-image"
        ] []

-- LAZY COLLECTIONS WITH KEYED NODES
viewRecipeGrid : List Recipe -> Html Msg
viewRecipeGrid recipes =
    div [ class "recipe-grid" ]
        (recipes
            |> List.map (\recipe -> 
                lazy2 Keyed.node "div"
                    [ key (Recipe.toId recipe) ]
                    [ lazy viewRecipeCardOptimized recipe ]
               )
        )
```

### Efficient State Updates with Focused Changes

#### Granular Model Updates
```elm
-- INEFFICIENT: UPDATES ENTIRE RECIPE COLLECTION
type alias IneffientModel =
    { recipes : List Recipe
    , selectedRecipes : List Recipe
    , searchResults : List Recipe
    }

-- EFFICIENT: FOCUSED UPDATES WITH DICTS AND SETS
type alias OptimizedModel =
    { recipes : Dict RecipeId Recipe
    , recipeOrder : List RecipeId
    , selectedRecipeIds : Set RecipeId
    , searchResultIds : List RecipeId
    , visibleRecipeIds : List RecipeId
    , recipesLoadState : Dict RecipeId LoadState
    }

-- FOCUSED UPDATE FUNCTIONS
updateRecipe : RecipeId -> (Recipe -> Recipe) -> OptimizedModel -> OptimizedModel
updateRecipe recipeId updateFn model =
    { model 
        | recipes = Dict.update recipeId (Maybe.map updateFn) model.recipes 
    }

-- BATCH UPDATES FOR MULTIPLE CHANGES
updateMultipleRecipes : List (RecipeId, Recipe -> Recipe) -> OptimizedModel -> OptimizedModel
updateMultipleRecipes updates model =
    updates
        |> List.foldl (\(id, updateFn) m -> updateRecipe id updateFn m) model

-- EFFICIENT SELECTION TOGGLE
toggleRecipeSelection : RecipeId -> OptimizedModel -> OptimizedModel
toggleRecipeSelection recipeId model =
    { model 
        | selectedRecipeIds = 
            if Set.member recipeId model.selectedRecipeIds then
                Set.remove recipeId model.selectedRecipeIds
            else
                Set.insert recipeId model.selectedRecipeIds
    }
```

### Optimized List Processing with Functional Composition

#### Efficient Recipe Filtering and Sorting
```elm
-- PIPELINE OPTIMIZATION FOR LARGE RECIPE COLLECTIONS
filterAndSortRecipes : FilterCriteria -> SortCriteria -> Dict RecipeId Recipe -> List RecipeId
filterAndSortRecipes filterCriteria sortCriteria recipes =
    recipes
        |> Dict.values
        |> List.filter (matchesFilter filterCriteria)    -- Early filtering
        |> List.take 100                                 -- Limit processing
        |> List.sortWith (compareRecipes sortCriteria)   -- Sort smaller set  
        |> List.map .id                                  -- Extract IDs only

-- MEMOIZED EXPENSIVE COMPUTATIONS
type alias ComputedRecipeData =
    { recipeId : RecipeId
    , totalTime : Int
    , difficulty : Difficulty  
    , nutritionScore : Float
    , lastUsed : Maybe Time.Posix
    }

-- CACHE EXPENSIVE CALCULATIONS
computeRecipeMetrics : Recipe -> ComputedRecipeData
computeRecipeMetrics recipe =
    -- This would be memoized/cached in practice
    { recipeId = recipe.id
    , totalTime = recipe.prepTime + recipe.cookTime
    , difficulty = calculateDifficulty recipe  -- Expensive calculation
    , nutritionScore = calculateNutrition recipe.ingredients  -- Very expensive
    , lastUsed = getLastUsedTime recipe.id     -- Database lookup
    }

-- EFFICIENT SEARCH WITH INDEXED RESULTS
performRecipeSearch : String -> SearchIndex -> OptimizedModel -> List RecipeId
performRecipeSearch query searchIndex model =
    if String.length query < 2 then
        model.recipeOrder  -- Return default order for empty search
    else
        let
            -- Use pre-computed search index
            nameMatches = SearchIndex.findByName query searchIndex
            ingredientMatches = SearchIndex.findByIngredient query searchIndex  
            tagMatches = SearchIndex.findByTag query searchIndex
            
            -- Combine and rank results
            allMatches = nameMatches ++ ingredientMatches ++ tagMatches
                |> List.Extra.unique
                |> List.take 50  -- Limit results for performance
                |> List.sortBy (calculateRelevanceScore query)
        in
        allMatches
```

### Memory-Efficient Data Structures

#### Normalized State Shape
```elm
-- MEMORY-EFFICIENT NORMALIZED STATE
type alias NormalizedState =
    { -- Entities stored by ID (no duplication)
      recipes : Dict RecipeId Recipe
    , ingredients : Dict IngredientId Ingredient  
    , tags : Dict TagId Tag
    , users : Dict UserId User
    
    -- Relationships stored as ID references
    , recipeIngredients : Dict RecipeId (List IngredientId)
    , recipeTags : Dict RecipeId (List TagId)  
    , userRecipes : Dict UserId (List RecipeId)
    
    -- UI State separate from data
    , ui : 
        { selectedRecipeIds : Set RecipeId
        , expandedTagIds : Set TagId
        , loading : Set EntityId
        , errors : Dict EntityId String
        }
    }

-- EFFICIENT DENORMALIZATION FOR VIEWS
getRecipeWithDetails : RecipeId -> NormalizedState -> Maybe RecipeDetails
getRecipeWithDetails recipeId state =
    Maybe.map3 RecipeDetails
        (Dict.get recipeId state.recipes)
        (Dict.get recipeId state.recipeIngredients 
            |> Maybe.map (List.filterMap (\id -> Dict.get id state.ingredients))
        )
        (Dict.get recipeId state.recipeTags
            |> Maybe.map (List.filterMap (\id -> Dict.get id state.tags))
        )
```

### Subscription Management for Performance

#### Intelligent Subscription Strategy
```elm
-- CONDITIONAL SUBSCRIPTIONS TO AVOID UNNECESSARY UPDATES
subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.batch
        [ -- Only subscribe to window resize when recipe grid is visible
          if model.currentPage == RecipePage then
              Browser.Events.onResize WindowResized
          else
              Sub.none
              
        -- Only subscribe to scroll when virtual scrolling is active
        , if model.recipesView == VirtualScrollView then
              Browser.Events.onScroll ScrollPositionChanged
          else
              Sub.none
              
        -- Auto-save timer only when recipe entry form has unsaved changes
        , if model.recipeEntry.isDirty && not model.recipeEntry.isSaving then
              Time.every 30000 AutoSaveRecipe
          else
              Sub.none
              
        -- Websocket connection only when shopping list is active
        , if model.shoppingListActive then
              ShoppingListSync.subscribe
          else
              Sub.none
        ]

-- DEBOUNCED SUBSCRIPTIONS FOR HIGH-FREQUENCY EVENTS  
type alias DebouncedSubscription =
    { lastEventTime : Time.Posix
    , pendingEvent : Maybe Msg
    , debounceTimer : Maybe Timer
    }

-- SEARCH INPUT DEBOUNCING
subscribeToSearchInput : Sub Msg
subscribeToSearchInput =
    Sub.map SearchInputChanged (
        Browser.Events.on "input"
            (D.field "target" (D.field "value" D.string))
            |> Sub.map (debounceMsg 300 PerformSearch)
    )
```

---

## Implementation Roadmap

### Performance Implementation Priority

#### Phase 1: Core Performance Foundation (Weeks 1-3)
1. **Database Schema & Indexing**
   - Implement optimized PostgreSQL schema with trigram indexes
   - Set up Redis caching layer for global ingredients/tags
   - Create F# database access layer with connection pooling

2. **Basic Lazy Loading**
   - Implement virtual scrolling for recipe collections
   - Add progressive loading with skeleton states
   - Create search debouncing for performance

#### Phase 2: Advanced Optimizations (Weeks 4-6)  
1. **Elm Performance Patterns**
   - Implement strategic `lazy` usage across components
   - Refactor to normalized state management
   - Add efficient subscription management

2. **Mobile PWA Features**
   - Implement service worker for offline shopping lists
   - Add background sync for shopping list updates
   - Optimize touch interactions with proper event handling

#### Phase 3: Performance Monitoring (Weeks 7-8)
1. **Performance Metrics**
   - Add application performance monitoring
   - Implement Core Web Vitals tracking
   - Create performance regression testing

2. **Advanced Mobile Optimizations**
   - Implement item pooling for large shopping lists
   - Add battery-efficient request batching
   - Optimize memory usage patterns

### Performance Testing Strategy

#### Load Testing Scenarios
1. **Large Recipe Collections**: Test with 500+ recipes
2. **Concurrent Users**: Simulate 100 users creating ingredients simultaneously
3. **Complex Shopping Lists**: Generate lists from 20+ recipes with scaling
4. **Mobile Performance**: Test on low-end devices with 3G connections

#### Performance Monitoring
- **Core Web Vitals**: LCP <2.5s, FID <100ms, CLS <0.1
- **Custom Metrics**: Recipe entry completion time, shopping list generation speed
- **Error Tracking**: Performance regressions, failed optimizations

---

*This performance planning document provides comprehensive optimization strategies for Zestro, ensuring the application remains fast and responsive as it scales from MVP to thousands of users with extensive recipe libraries.*